name: CSharp SWFT Container CI (Build/SBOM/Scan Only)

on:
  push:
    branches: [ main ]
    paths:
      - 'c-sharp/**'
      - '.github/workflows/csharp/csharp-swft.yml'
  pull_request:
    paths:
      - 'c-sharp/**'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  ACR_LOGIN_SERVER:    ${{ secrets.ACR_LOGIN_SERVER }}
  ACR_USERNAME:        ${{ secrets.ACR_USERNAME }}
  ACR_PASSWORD:        ${{ secrets.ACR_PASSWORD }}
  REPO_NAME:           ${{ github.event.repository.name }}
  IMAGE_NAME:          csharp-demo
  ARCH:                amd64  
  # Tag standard: repo_container_architecture_tag (here tag=commit SHA). Example: myrepo_csharp-demo_amd64_abcdef1
  IMAGE_TAG:           ${{ github.event.repository.name }}_${{ env.IMAGE_NAME }}_${{ env.ARCH }}_${{ github.sha }}
  AZURE_RESOURCE_GROUP: demo-swft-cicd
  AZURE_CONTAINER_NAME: swft-fastapi
  AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
  AZURE_STORAGE_KEY:     ${{ secrets.AZURE_STORAGE_KEY }}
  # SonarQube project settings (override via repository/organization secrets as needed)
  SONAR_PROJECT_KEY: csharp-hello-world
  SONAR_PROJECT_NAME: CSharp Hello World
  # Directory containing the C# solution / project
  CS_PROJECT_PATH: c-sharp/src/HelloWorld/HelloWorld.csproj
  BUILD_CONFIGURATION: Release
  # Docker build context directory and Dockerfile path
  BUILD_CONTEXT:       c-sharp
  DOCKERFILE:          c-sharp/Dockerfile

jobs:
  build-and-scan:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Trivy
        uses: aquasecurity/setup-trivy@v0.2.1

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Restore .NET dependencies
        run: dotnet restore $CS_PROJECT_PATH

      - name: Build (.NET)
        run: dotnet build $CS_PROJECT_PATH --configuration $BUILD_CONFIGURATION --no-restore

      - name: Test (.NET) with coverage
        run: |
          dotnet test $CS_PROJECT_PATH \
            --configuration $BUILD_CONFIGURATION \
            --no-build \
            /p:CollectCoverage=true \
            /p:CoverletOutputFormat=opencover \
            /p:CoverletOutput=./TestResults/coverage-
          echo "Generated coverage files:" && ls -R . | grep -i opencover || true

      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          args: >-
            -Dsonar.projectKey=${{ env.SONAR_PROJECT_KEY }}
            -Dsonar.projectName="${{ env.SONAR_PROJECT_NAME }}"
            -Dsonar.cs.opencover.reportsPaths=**/coverage*.opencover.xml
            -Dsonar.sourceEncoding=UTF-8

      - name: SonarQube Quality Gate # Pipeline quality check
        uses: SonarSource/sonarqube-quality-gate-action@v1.1.0
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: Upload coverage artifact (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
            name: dotnet-coverage-${{ env.IMAGE_TAG }}
            path: |
              **/coverage*.opencover.xml
            if-no-files-found: warn

      # - name: Azure Login
      #   uses: azure/login@v1
      #   with:
      #     creds: ${{ secrets.AZURE_CREDENTIALS }}

      # - name: Log in to ACR
      #   run: |
      #     echo "$ACR_PASSWORD" \
      #       | docker login "$ACR_LOGIN_SERVER" \
      #                     -u "$ACR_USERNAME" \
      #                     --password-stdin

    
      - name: Build Docker image
        run: |
          echo "Building & pushing $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG from $DOCKERFILE"
          docker buildx build \
            -f "$DOCKERFILE" \
            -t "$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG" \
            --push \
            "$BUILD_CONTEXT"

      # --- COSIGN SIGNING & VERIFICATION (Commented placeholders) ---
      # To enable keyless signing (Sigstore Cosign) using OIDC (GitHub Actions issuer), uncomment the steps below.
      # Prerequisites:
      #   permissions: id-token: write (already set) and contents: read
      #   No private key required (keyless). Cosign will issue an ephemeral cert bound to workflow identity.
      # Optional: set COSIGN_YES=1 to auto-confirm.
      # References:
      #   https://docs.sigstore.dev/cosign/keyless/
      #   https://github.com/sigstore/cosign

      # - name: Install Cosign
      #   uses: sigstore/cosign-installer@v3.4.0
      #   with:
      #     cosign-release: 'v2.2.4'

      # - name: Keyless sign image with Cosign # Pipeline supply chain enhancement
      #   env:
      #     COSIGN_EXPERIMENTAL: 1
      #     COSIGN_YES: 1
      #   run: |
      #     echo "Signing image (keyless): $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG"
      #     cosign sign $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG \
      #       --annotations repo=$REPO_NAME commit=${GITHUB_SHA} arch=$ARCH build_ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
      # --------------------------------------------------------------


      - name: Generate SBOM (Syft via Anchore Action)
        uses: anchore/sbom-action@v0.20.1
        with:
          image: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format: cyclonedx-json
          output-file: sbom.cyclonedx.json
          upload-artifact: false

      - name: CVE Scan (Trivy) and enforce severity gate # Pipeline quality check
        run: |
          trivy image \
            --format json \
            --output trivy-report.json \
            --severity HIGH,CRITICAL \
            --ignore-unfixed \
            --exit-code 1 \
            "$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG" || {
              echo "High/Critical vulnerabilities detected. See trivy-report.json"; exit 1; }

      
      - name: Stub: Upload SBOM to DoD SWFT REST API
        run: |
          echo "ðŸŸ¡ STUB: Would POST SBOM to DoD SWFT API"
          echo "Endpoint: https://api.swft.dod.mil/v1/sboms"
          echo "Auth: Bearer ${{ secrets.DO_D_SWFT_API_TOKEN || '***missing-secret***' }}"
          echo "Payload: { image: '$IMAGE_NAME', tag: '$IMAGE_TAG' }"



      - name: Completed
        run: echo "âœ… Build & security analysis (local) steps completed successfully. Not deploying artifacts to ACI or Storage Account yet"
 
      # - name: Verify image signature (Cosign keyless) # Pipeline quality check
      #   run: |
      #     echo "Verifying signature for: $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG"
      #     cosign verify $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG \
      #       --certificate-identity-regexp "https://github.com/${{ github.repository }}.*" \
      #       --certificate-oidc-issuer https://token.actions.githubusercontent.com
      #     echo "Signature verification succeeded."