name: SWFT Container CI/CD

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  ACR_LOGIN_SERVER:    ${{ secrets.ACR_LOGIN_SERVER }}
  ACR_USERNAME:        ${{ secrets.ACR_USERNAME }}
  ACR_PASSWORD:        ${{ secrets.ACR_PASSWORD }}
  IMAGE_NAME:          fastapi-demo
  IMAGE_TAG:           ${{ secrets.IMAGE_TAG }}
  AZURE_RESOURCE_GROUP: demo-swft-cicd
  AZURE_CONTAINER_NAME: swft-fastapi
  AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
  AZURE_STORAGE_KEY:     ${{ secrets.AZURE_STORAGE_KEY }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Install Trivy
        uses: aquasecurity/setup-trivy@v0.2.1

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.9.0

      - name: Checkout source
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to ACR
        run: |
          echo "$ACR_PASSWORD" \
            | docker login "$ACR_LOGIN_SERVER" \
                          -u "$ACR_USERNAME" \
                          --password-stdin


      - name: Decode Cosign private key
        run: |
          echo "${{ secrets.COSIGN_KEY_B64 }}" | base64 -d > cosign.key
          chmod 600 cosign.key

      - name: Decode Cosign public key
        run: |
          echo "${{ secrets.COSIGN_PUB_KEY_B64 }}" | base64 -d > cosign.pub
          chmod 644 cosign.pub



      - name: Build Docker image
        run: |
          docker buildx build \
            -t "$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG" \
            --push \
            .

      - name: Sign the image with Cosign (registry-only)
        run: |
          cosign sign \
            --key cosign.key \
            --tlog-upload=false \
            ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}



      - name: Generate SBOM (Syft)
        uses: anchore/sbom-action@v0.20.1
        with:
          image:        ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format:       cyclonedx-json
          output-file:  sbom.cyclonedx.json
          upload-artifact: false

      - name: CVE Scan and save report (Trivy)
        run: |
          trivy image \
            --format json \
            --output trivy-report.json \
            --severity HIGH,CRITICAL \
            --ignore-unfixed \
            "$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG"


      - name: Upload SBOM to Azure Storage
        run: |
          az storage blob upload \
            --account-name "$AZURE_STORAGE_ACCOUNT" \
            --container-name sboms \
            --file sbom.cyclonedx.json \
            --name "${IMAGE_NAME}-${IMAGE_TAG}-sbom.json" \
            --overwrite \
            --auth-mode login
        env:
          AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}


      - name: Upload Trivy report to Azure Storage
        run: |
          az storage blob upload \
            --account-name "$AZURE_STORAGE_ACCOUNT" \
            --container-name scans \
            --file trivy-report.json \
            --name "${IMAGE_NAME}-${IMAGE_TAG}-trivy.json" \
            --overwrite \
            --auth-mode login
        env:
          AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}


      - name: Upload SBOM and Trivy report to DoD SWFT REST API (stubbed)
        run: |
          echo "ðŸŸ¡ STUB: Would POST SBOM and Trivy report to DoD SWFT API"
          echo "Endpoint: https://api.swft.dod.mil/v1/sboms"
          echo "Auth: Bearer ${{ secrets.DO_D_SWFT_API_TOKEN }}"
          echo "SBOM Payload: ${{ env.IMAGE_NAME }}-${{ env.IMAGE_TAG }} (sbom.cyclonedx.json)"
          echo "Trivy Payload: ${{ env.IMAGE_NAME }}-${{ env.IMAGE_TAG }} (trivy-report.json)"



      - name: Upload all artifacts to Azure Blob Storage
        uses: azure/CLI@v2
        env:
          AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        with:
          inlineScript: |
            if compgen -G "./artifacts/*" > /dev/null; then
              for file in ./artifacts/*; do
                filename=$(basename "$file")
                echo "Uploading $filename..."
                az storage blob upload \
                  --account-name "$AZURE_STORAGE_ACCOUNT" \
                  --container-name artifacts \
                  --file "$file" \
                  --name "${IMAGE_TAG}-${filename}" \
                  --overwrite \
                  --auth-mode login
              done
            else
              echo "No files found in ./artifacts/ â€” skipping upload."
            fi


      - name: Decode and write Cosign public key
        run: |
          echo "${{ secrets.COSIGN_PUB_KEY_B64 }}" | base64 -d > cosign.pub
          chmod 644 cosign.pub



      - name: Verify container signature before deploy
        run: |
          cosign verify \
            --key cosign.pub \
            --insecure-ignore-tlog \
            ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}


      - name: Deploy to Azure Container Instance
        shell: bash
        env:
          AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
          AZURE_CONTAINER_NAME: ${{ env.AZURE_CONTAINER_NAME }}
          ACR_LOGIN_SERVER:     ${{ env.ACR_LOGIN_SERVER }}
          ACR_USERNAME:         ${{ secrets.ACR_USERNAME }}
          ACR_PASSWORD:         ${{ secrets.ACR_PASSWORD }}
          IMAGE_NAME:           ${{ env.IMAGE_NAME }}
          IMAGE_TAG:            ${{ env.IMAGE_TAG }}
        run: |
          echo "Checking if container instance exists..."
          if az container show \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$AZURE_CONTAINER_NAME" \
              --only-show-errors \
              --output none 2>/dev/null; then
            echo "Container exists. Deleting and recreating..."
            az container delete \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$AZURE_CONTAINER_NAME" \
              --yes

            echo "Waiting for container deletion..."
            for i in {1..30}; do
              if ! az container show --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_CONTAINER_NAME" &>/dev/null; then
                echo "âœ… Container deleted."
                break
              fi
              echo "... Still deleting... retry $i"
              sleep 5
            done
          else
            echo "Container does not exist. Creating..."
          fi

          echo "Creating container instance..."
          az container create \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$AZURE_CONTAINER_NAME" \
            --image "$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG" \
            --registry-login-server "$ACR_LOGIN_SERVER" \
            --registry-username     "$ACR_USERNAME" \
            --registry-password     "$ACR_PASSWORD" \
            --cpu 1 --memory 1 \
            --os-type Linux \
            --ports 80 \
            --ip-address Public

          echo "Fetching container public IP..."
          PUBLIC_IP=$(az container show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$AZURE_CONTAINER_NAME" \
            --query "ipAddress.ip" -o tsv)

          echo "âœ… Container is deployed and accessible at: http://$PUBLIC_IP"