name: SWFT Container CI/CD

on:
  push:
    branches: [ main ]
    paths:
      - "python/**"
  pull_request:
    branches: [ main ]
    paths:
      - "python/**"
  workflow_dispatch:
    inputs:
      project_name:
        description: "Logical Project Name for SWFT tracking"
        type: string
        default: "swft-demo"
      upload_to_azure:
        description: "Upload SBOM/scan/run JSON to Azure Storage (SAS token)"
        type: boolean
        default: true
      upload_artifacts:
        description: "Upload SBOM/scan/run JSON as GitHub Artifacts"
        type: boolean
        default: true
      trivy_config:
        description: "scan=<levels>;ignore_unfixed=<true|false>;fail=<levels>"
        type: string
        default: "scan=HIGH,CRITICAL;ignore_unfixed=true;fail=CRITICAL"
      storage_containers:
        description: "sboms,scans,runs"
        type: string
        default: "sboms,scans,runs"
      fail_on_trivy:
        description: "Fail the workflow if FAIL set has findings (manual runs only)"
        type: boolean
        default: false
      fail_on_cosign_verify:
        description: "Fail the workflow if Cosign verify fails"
        type: boolean
        default: true

permissions:
  contents: read
  id-token: write
  security-events: write

env:
  # Registry
  ACR_LOGIN_SERVER:     ${{ secrets.ACR_LOGIN_SERVER }}
  ACR_USERNAME:         ${{ secrets.ACR_USERNAME }}
  ACR_PASSWORD:         ${{ secrets.ACR_PASSWORD }}
  IMAGE_NAME:           fastapi-demo
  IMAGE_TAG:            ${{ secrets.IMAGE_TAG }}

  # Azure targets
  AZURE_RESOURCE_GROUP: demo-swft-cicd
  AZURE_CONTAINER_NAME: swft-fastapi
  AZURE_STORAGE_ACCOUNT: ${{ vars.STORAGE_ACCOUNT }}
  AZ_SAS_TOKEN_STORAGE: ${{ secrets.AZ_SAS_TOKEN_STORAGE }}

  # Defaults for push runs (used if no override via trivy_config)
  TRIVY_SEVERITY:       HIGH,CRITICAL
  TRIVY_IGNORE_UNFIXED: true

  # Names & IDs
  PROJECT_NAME: ${{ github.event_name == 'workflow_dispatch' && inputs.project_name || vars.PROJECT_NAME || github.event.repository.name }}
  RUN_ID:       ${{ github.run_id }}
  RUN_NUMBER:   ${{ github.run_number }}

  # FIXED artifact filenames (we always create & upload these)
  SBOM_SRC:     sbom.cyclonedx.json
  TRIVY_SRC:    trivy-report.json
  SARIF_SRC:    trivy-results.sarif
  DEPLOY_SRC:   aci-endpoint.txt
  RUNJSON_SRC:  run.json
  INSPECT_SRC:  docker-inspect.json

jobs:
  build-and-upload:
    runs-on: self-hosted
    permissions:
      contents: read
      id-token: write
      security-events: write
    defaults: { run: { shell: bash } }

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug show commit & files
        run: |-
          set -e
          echo "=== Environment ==="
          echo "GITHUB_REF: $GITHUB_REF"
          echo "GITHUB_SHA: $GITHUB_SHA"
          echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
          echo -e "\n=== Repository Status ==="
          git status
          echo -e "\n=== Workflow File Info ==="
          echo "Looking for workflow file at: .github/workflows/deploy.yml"
          if [ -f ".github/workflows/deploy.yml" ]; then
            echo "Workflow file exists at the expected location"
            git log -1 --pretty=oneline -- .github/workflows/deploy.yml || echo "No git history found for workflow file"
          else
            echo "Workflow file NOT found at .github/workflows/deploy.yml"
            echo "Current directory: $(pwd)"
            echo -e "\n=== Directory Contents ==="
            ls -la
            echo -e "\n=== .github/ Contents ==="
            ls -la .github/ 2>/dev/null || echo ".github/ directory not found"
            echo -e "\n=== .github/workflows/ Contents ==="
            ls -la .github/workflows/ 2>/dev/null || echo ".github/workflows/ directory not found"
          fi
          echo -e "\n=== Python Directory ==="
          if [ -d "python" ]; then
            ls -la python
          else
            echo "python/ directory not found"
          fi

      - name: Guard ensure python/requirements.txt exists
        run: |
          test -f python/requirements.txt || {
            echo "::error::python/requirements.txt is missing in this checkout";
            exit 12;
          }

      # === QUALITY CHECKS (uses same Azure auth) ===
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('python/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install deps & test with coverage
        run: |
          python -m pip install --upgrade pip
          pip install -r python/requirements.txt
          if [ -f python/requirements-dev.txt ]; then pip install -r python/requirements-dev.txt; fi
          cd python && \
          pytest tests/ -v --cov=app --cov-report=xml:coverage.xml

      - name: Set up Java (for Sonar scanner)
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      
      - name: Test SonarQube Connection
        run: |
          echo "Testing SonarQube connection..."
          echo "SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}"
          curl -v -I ${{ secrets.SONAR_HOST_URL }}
          curl -v ${{ secrets.SONAR_HOST_URL }}/api/server/version

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_SCANNER_OPTS: -Dproject.settings=python/sonar-project.properties
          

      - name: SonarQube Quality Gate (Non-blocking for vulnerability testing)
        uses: SonarSource/sonarqube-quality-gate-action@v1
        timeout-minutes: 15
        continue-on-error: true  # Allow pipeline to continue even if quality gate fails
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: Display SonarQube Results Summary
        if: always()
        run: |
          echo "=== SonarQube Analysis Complete ==="
          echo "âœ… SonarQube scan completed successfully"
          echo "âš ï¸ Quality Gate status: Check dashboard for detected vulnerabilities"
          echo ""
          echo "ðŸ” View detailed results at:"
          echo "${{ secrets.SONAR_HOST_URL }}/dashboard?id=swft-python"
          echo ""
          echo "ðŸš¨ Expected security findings in this test project:"
          echo "â€¢ Security Hotspots: Hardcoded credentials, command injection, SQL injection"
          echo "â€¢ Code Smells: Weak cryptography, information disclosure"
          echo "â€¢ Bugs: Insecure deserialization, path traversal"
          echo ""
          echo "This is a test project with intentional vulnerabilities for security scanning validation."

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: python
          source-root: .  # adjust if your code is in a subfolder

      - name: Autobuild (CodeQL)
        uses: github/codeql-action/autobuild@v4

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
        with:
          category: "security"  # label for SARIF results

      # Export CodeQL database and SARIF results
      - name: Export CodeQL Databases and SARIF
        if: always()
        run: |
          set -euo pipefail
          echo "=== Exporting CodeQL Databases and SARIF ==="

          CODEQL_CLI="/opt/codeql/codeql"
          echo "ðŸ” Using CodeQL CLI at: $CODEQL_CLI"
          $CODEQL_CLI --version

          # Base folder where CodeQL stores databases
          DB_BASE="/home/scai/actions-runner/_work/_temp/codeql_databases"
          EXPORT_DIR="codeql-export"
          mkdir -p "$EXPORT_DIR"

          # Find all language-specific databases
          LANG_DB_FOLDERS=$(find "$DB_BASE" -mindepth 1 -maxdepth 2 -type d)
          if [ -z "$LANG_DB_FOLDERS" ]; then
            echo "âŒ No CodeQL language databases found"
            exit 1
          fi

          for DB_PATH in $LANG_DB_FOLDERS; do
            LANG_NAME=$(basename "$DB_PATH")
            DB_BUNDLE="$EXPORT_DIR/codeql-database-$LANG_NAME.tar.gz"
            echo "ðŸ“¦ Bundling database for language '$LANG_NAME'..."
            if $CODEQL_CLI database bundle --output="$DB_BUNDLE" "$DB_PATH"; then
              echo "âœ… Database bundled: $DB_BUNDLE"
            else
              echo "âš ï¸ Skipping $DB_PATH: not a valid CodeQL database"
              continue
            fi
          done

          # Copy SARIF result files from CodeQL analyze output
          SARIF_SRC_DIR="${CODEQL_ACTION_SARIF_RESULTS_OUTPUT_DIR:-$GITHUB_WORKSPACE}"
          echo "ðŸ” Searching for SARIF files in $SARIF_SRC_DIR"
          SARIF_FILES=$(find "$SARIF_SRC_DIR" -name "*.sarif")
          if [ -z "$SARIF_FILES" ]; then
            echo "âš ï¸ No SARIF files found in $SARIF_SRC_DIR"
          else
            for f in $SARIF_FILES; do
              cp "$f" "$EXPORT_DIR/"
              echo "ðŸ“„ Copied SARIF file: $f"
            done
          fi

          echo "ðŸ“‚ Exported files in $EXPORT_DIR:"
          ls -la "$EXPORT_DIR"

      - name: Normalize CodeQL SARIF filename
        if: always()
        run: |
          set -euo pipefail

          # Find CodeQL SARIF copied into codeql-export/
          CODEQL_SARIF_IN=$(ls -1 codeql-export/*.sarif 2>/dev/null | grep -vi trivy | head -1 || true)

          if [ -z "$CODEQL_SARIF_IN" ]; then
            echo "âš ï¸ No CodeQL SARIF found in codeql-export/"
            ls -la codeql-export || true
            exit 0
          fi

          CODEQL_SARIF_OUT="${PROJECT_NAME}-${RUN_ID}-codeql.sarif"
          cp "$CODEQL_SARIF_IN" "$CODEQL_SARIF_OUT"
          test -s "$CODEQL_SARIF_OUT"

          echo "CODEQL_SARIF_OUT=$CODEQL_SARIF_OUT" >> $GITHUB_ENV
          echo "âœ… CodeQL SARIF ready: $CODEQL_SARIF_OUT"
          ls -la "$CODEQL_SARIF_OUT"


      # === Derive names ===

      - name: Derive pretty names & timestamp
        run: |
          set -euo pipefail
          FILE_PREFIX="${PROJECT_NAME}-${RUN_ID}"
          {
            echo "FILE_PREFIX=$FILE_PREFIX"
            echo "SBOM_FILE=${FILE_PREFIX}-sbom.json"
            echo "TRIVY_FILE=${FILE_PREFIX}-trivy.json"
            echo "SARIF_FILE=${FILE_PREFIX}-trivy.sarif"
            echo "CODEQL_DB_FILE=${FILE_PREFIX}-codeql-db.tar.gz"
            echo "DEPLOY_FILE=${FILE_PREFIX}-deploy.txt"
            echo "RUN_JSON_FILE=${FILE_PREFIX}-run.json"
            echo "INSPECT_SRC=${FILE_PREFIX}-docker-inspect.json"

            # Override the generic names so all later steps use run-scoped filenames
            echo "SBOM_SRC=${FILE_PREFIX}-sbom.cyclonedx.json"
            echo "TRIVY_SRC=${FILE_PREFIX}-trivy-report.json"
            echo "SARIF_SRC=${FILE_PREFIX}-trivy-results.sarif"
            echo "RUNJSON_SRC=${FILE_PREFIX}-run.json"


            echo "ACTIONS_RUN_URL=https://github.com/${GITHUB_REPOSITORY}/actions/runs/${RUN_ID}"
            echo "RUN_TIMESTAMP=$(date -u +%FT%TZ)"
          } >> $GITHUB_ENV

      - name: Parse inputs (Trivy + containers + switches)
        id: cfg
        run: |
          set -euo pipefail
          # ---- Trivy config
          TC="${{ github.event_name == 'workflow_dispatch' && inputs.trivy_config || '' }}"
          [ -z "$TC" ] && TC="scan=${TRIVY_SEVERITY};ignore_unfixed=${TRIVY_IGNORE_UNFIXED};fail=CRITICAL"
          SCAN=$(echo "$TC" | sed -n 's/.*scan=\([^;]*\).*/\1/p'); [ -z "$SCAN" ] && SCAN="${TRIVY_SEVERITY}"
          IGN=$(echo "$TC"  | sed -n 's/.*ignore_unfixed=\([^;]*\).*/\1/p'); [ -z "$IGN" ] && IGN="${TRIVY_IGNORE_UNFIXED}"
          FAIL=$(echo "$TC" | sed -n 's/.*fail=\([^;]*\).*/\1/p'); [ -z "$FAIL" ] && FAIL="CRITICAL"
          echo "scan_levels=$SCAN"         >> $GITHUB_OUTPUT
          echo "ignore_unfixed=$IGN"       >> $GITHUB_OUTPUT
          echo "fail_levels=$FAIL"         >> $GITHUB_OUTPUT

          # ---- Containers
          CS="${{ github.event_name == 'workflow_dispatch' && inputs.storage_containers || '' }}"
          [ -z "$CS" ] && CS="sboms,scans,runs"
          IFS=',' read -r CN_SBOM CN_SCAN CN_RUNS <<< "$CS"
          echo "cn_sbom=${CN_SBOM:-sboms}" >> $GITHUB_OUTPUT
          echo "cn_scan=${CN_SCAN:-scans}" >> $GITHUB_OUTPUT
          echo "cn_runs=${CN_RUNS:-runs}"  >> $GITHUB_OUTPUT

          # ---- Effective switches (works for push AND manual)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            AZ="${{ inputs.upload_to_azure }}"
            AR="${{ inputs.upload_artifacts }}"
          else
            AZ="${{ vars.UPLOAD_TO_AZURE || 'true' }}"
            AR="${{ vars.UPLOAD_ARTIFACTS || 'true' }}"
          fi
          echo "upload_to_azure=$AZ"  >> $GITHUB_OUTPUT
          echo "upload_artifacts=$AR" >> $GITHUB_OUTPUT

      # === DOCKER BUILD & DEPLOY (uses same Azure auth) ===

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ACR_LOGIN_SERVER }}
          username: ${{ env.ACR_USERNAME }}
          password: ${{ env.ACR_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ./python  
          push: true
          tags: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Pull image for local scan
        run: docker pull "${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

      - name: Get image digest
        run: |
          set -euo pipefail
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${ACR_LOGIN_SERVER}/${IMAGE_NAME}:${IMAGE_TAG}" | awk -F'@' '{print $2}')
          echo "IMAGE_DIGEST=$DIGEST" >> $GITHUB_ENV
      
      - name: Docker Inspect Image (save JSON)
        run: |
            set -euo pipefail
            REF="${ACR_LOGIN_SERVER}/${IMAGE_NAME}@${IMAGE_DIGEST}"
            echo "Inspecting: $REF"
            docker inspect "$REF" > "${INSPECT_SRC}"
            test -s "${INSPECT_SRC}"
            ls -la "${INSPECT_SRC}"

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.9.0

      - name: Decode Cosign keys
        run: |
          set -euo pipefail
          echo "${{ secrets.COSIGN_KEY_B64 }}" | base64 -d > cosign.key
          echo "${{ secrets.COSIGN_PUB_KEY_B64 }}" | base64 -d > cosign.pub
          chmod 600 cosign.key
          chmod 644 cosign.pub


      - name: Sign image (keyed)
        env:
          COSIGN_YES: "true"   # <- auto-answer "yes" to prompts
        run: |
          set -euo pipefail
          REF="${ACR_LOGIN_SERVER}/${IMAGE_NAME}@${IMAGE_DIGEST}"
          echo "ðŸ”‘ Signing image with cosign key: $REF"
          cosign sign --key cosign.key "$REF"
          echo "COSIGN_VERIFY_STATUS=signed" >> $GITHUB_ENV


      - name: Verify image signature (keyed)
        run: |
          set +e
          REF="${ACR_LOGIN_SERVER}/${IMAGE_NAME}@${IMAGE_DIGEST}"
          echo "ðŸ” Verifying image signature: $REF"
          
          if cosign verify --key cosign.pub "$REF"; then
              echo "âœ… Image signature verification passed"
              echo "COSIGN_VERIFY_STATUS=passed" >> $GITHUB_ENV
          else
              echo "âš ï¸  Image signature verification failed"
              echo "COSIGN_VERIFY_STATUS=failed" >> $GITHUB_ENV
          fi

      - name: Sign Docker inspect JSON
        if: ${{ hashFiles(env.INSPECT_SRC) != '' }}
        env:
          COSIGN_YES: "true"
        run: |
          set -euo pipefail
          ARTIFACT="${INSPECT_SRC}"
          cosign sign-blob \
            --key cosign.key \
            --output-signature "${ARTIFACT}.sig" \
            "${ARTIFACT}"
          ls -l "${ARTIFACT}.sig"

      # === GENERATE FILES WITH OFFICIAL ACTIONS (fixed names) ===
      - name: Generate SBOM (Syft via Anchore)
        uses: anchore/sbom-action@v0.20.1
        with:
          image:        ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format:       cyclonedx-json
          output-file:  ${{ env.SBOM_SRC }}
          upload-artifact: false
       

      - name: Verify SBOM exists
        run: |
          set -euo pipefail
          test -s "${SBOM_SRC}" || { echo "SBOM not created"; ls -la; exit 2; }

      - name: Cosign sign SBOM (sbom)
        if: ${{ hashFiles(env.SBOM_SRC) != '' }}
        env:
          COSIGN_YES: "true"
        run: |
          set -euo pipefail
          ARTIFACT="${SBOM_SRC}"
          cosign sign-blob \
            --key cosign.key \
            --output-signature "${ARTIFACT}.sig" \
            "${ARTIFACT}"
          ls -l "${ARTIFACT}.sig"


      - name: Run Trivy vulnerability scanner (JSON)
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_USERNAME: ${{ env.ACR_USERNAME }}
          TRIVY_PASSWORD: ${{ env.ACR_PASSWORD }}
        with:
          version: 'v0.66.0'
          scan-type: 'image'
          image-ref: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format: 'json'
          output: ${{ env.TRIVY_SRC }}
          severity: ${{ steps.cfg.outputs.scan_levels }}
          ignore-unfixed: ${{ steps.cfg.outputs.ignore_unfixed }}
          scanners: 'vuln'
          exit-code: '0'

      - name: Verify Trivy JSON exists
        run: |
          set -euo pipefail
          test -s "${TRIVY_SRC}" || { echo "Trivy JSON not created"; ls -la; exit 2; }

      - name: Cosign sign Trivy JSON
        if: ${{ hashFiles(env.TRIVY_SRC) != '' }}
        env:
          COSIGN_YES: "true"
        run: |
          set -euo pipefail
          ARTIFACT="${TRIVY_SRC}"
          cosign sign-blob \
            --key cosign.key \
            --output-signature "${ARTIFACT}.sig" \
            "${ARTIFACT}"
          ls -l "${ARTIFACT}.sig"

      - name: Generate Trivy SARIF
        uses: aquasecurity/trivy-action@0.33.1
        with:
          version: 'v0.66.0'
          scan-type: 'image'
          image-ref: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: ${{ env.SARIF_SRC }}
          severity: ${{ steps.cfg.outputs.scan_levels }}
          ignore-unfixed: ${{ steps.cfg.outputs.ignore_unfixed }}
          scanners: 'vuln'
          exit-code: '0'

      - name: Verify Trivy SARIF exists
        run: |
          set -euo pipefail
          test -s "${SARIF_SRC}" || { echo "Trivy SARIF not created"; ls -la; exit 2; }
      
      - name: Cosign sign Trivy SARIF
        if: ${{ hashFiles(env.SARIF_SRC) != '' }}
        env:
          COSIGN_YES: "true"
        run: |
          set -euo pipefail
          ARTIFACT="${SARIF_SRC}"
          cosign sign-blob \
            --key cosign.key \
            --output-signature "${ARTIFACT}.sig" \
            "${ARTIFACT}"
          ls -l "${ARTIFACT}.sig"

      - name: Cosign sign CodeQL SARIF
        if: ${{ env.CODEQL_SARIF_OUT != '' && hashFiles(env.CODEQL_SARIF_OUT) != '' }}
        env:
          COSIGN_YES: "true"
        run: |
          set -euo pipefail
          cosign sign-blob \
            --key cosign.key \
            --output-signature "${CODEQL_SARIF_OUT}.sig" \
            "${CODEQL_SARIF_OUT}"
          test -s "${CODEQL_SARIF_OUT}.sig"
          ls -la "${CODEQL_SARIF_OUT}.sig"
      
          

      - name: Ensure jq present (for policy)
        run: jq --version || (sudo apt-get update -y && sudo apt-get install -y jq)

      - name: Enforce Trivy policy (fail only on selected severities)
        env:
          POLICY_FAIL_ON_TRIVY:  ${{ github.event_name == 'workflow_dispatch' && inputs.fail_on_trivy || (vars.FAIL_ON_TRIVY || 'false') }}
          SCAN_LEVELS:           ${{ steps.cfg.outputs.scan_levels }}
          FAIL_LEVELS:           ${{ steps.cfg.outputs.fail_levels }}
        run: |
          set -euo pipefail
          TOTAL_COUNT=$(jq --arg sev "$SCAN_LEVELS" '
            [ .Results[].Vulnerabilities[]? as $v
              | ($sev | split(",")) as $levels
              | select($levels | index($v.Severity))
            ] | length' "${TRIVY_SRC}")
          FAIL_COUNT=$(jq --arg sev "$FAIL_LEVELS" '
            [ .Results[].Vulnerabilities[]? as $v
              | ($sev | split(",")) as $levels
              | select($levels | index($v.Severity))
            ] | length' "${TRIVY_SRC}")
          echo "TRIVY_FINDINGS_TOTAL=$TOTAL_COUNT" >> $GITHUB_ENV
          echo "TRIVY_FINDINGS_FAILSET=$FAIL_COUNT" >> $GITHUB_ENV
          if [ "$POLICY_FAIL_ON_TRIVY" = "true" ] && [ "$FAIL_COUNT" -gt 0 ]; then
            echo "Failing due to findings in fail set ($FAIL_LEVELS): $FAIL_COUNT"
            exit 1
          fi

      - name: Upload SARIF to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: ${{ env.SARIF_SRC }}
        # category intentionally omitted (single SARIF)

      # ---------- Azure uploads (work on push and manual; FLAT filenames) ----------
      - name: Upload Docker inspect JSON to Azure Storage 
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            az cloud show 
            SUFFIX="$(az cloud show --query suffixes.storageEndpoint -o tsv)"

            CN="${{ steps.cfg.outputs.cn_scan || 'scans' }}"
            test -s "${INSPECT_SRC}" || { echo "Inspect JSON missing"; ls -la; exit 2; }

            echo "Uploading the inspect.json to azure storage..."

            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "$CN" \
              --name "${INSPECT_SRC}" \
              --file "${INSPECT_SRC}" \
              --overwrite true
            
            echo "Docker inspect json uploaded successfully"

            echo "DOCKER_INSPECT_URL=https://${AZURE_STORAGE_ACCOUNT}.blob.${SUFFIX}/${CN}/${INSPECT_SRC}" >> $GITHUB_ENV

      - name: Upload Docker inspect signature to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' && hashFiles(format('{0}.sig', env.INSPECT_SRC)) != '' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            SUFFIX="$(az cloud show --query suffixes.storageEndpoint -o tsv)"
            CN="${{ steps.cfg.outputs.cn_scan || 'scans' }}"

            SIG="${INSPECT_SRC}.sig"
            test -s "$SIG"

            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "$CN" \
              --name "$SIG" \
              --file "$SIG" 
      
      - name: Upload SBOM to Azure Storage (SAS)
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            az cloud show

            echo "Uploading SBOM to Azure Storage..."
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "${{ steps.cfg.outputs.cn_sbom || 'sboms' }}" \
              --name "${SBOM_SRC}" \
              --file "${SBOM_SRC}" \
              --overwrite true
            echo "SBOM uploaded successfully"

      - name: Upload SBOM signature to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' && hashFiles(format('{0}.sig', env.SBOM_SRC)) != '' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            SIG="${SBOM_SRC}.sig"
            test -s "$SIG"
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "${{ steps.cfg.outputs.cn_sbom || 'sboms' }}" \
              --name "$SIG" \
              --file "$SIG" 

      - name: Upload Trivy report to Azure Storage (flat name)
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            echo "Uploading Trivy report to Azure Storage..."
            az cloud set --name AzureUSGovernment
            az cloud show
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "${{ steps.cfg.outputs.cn_scan || 'scans' }}" \
              --name "${TRIVY_SRC}" \
              --file "${TRIVY_SRC}" \
              --overwrite true
            echo "Trivy report uploaded successfully"

      - name: Upload Trivy JSON signature to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' && hashFiles(format('{0}.sig', env.TRIVY_SRC)) != '' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            SIG="${TRIVY_SRC}.sig"
            test -s "$SIG"
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "${{ steps.cfg.outputs.cn_scan || 'scans' }}" \
              --name "$SIG" \
              --file "$SIG"
            echo "Trivy JSON signature uploaded successfully"

      - name: Upload Trivy SARIF to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            az cloud show
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "${{ steps.cfg.outputs.cn_scan || 'scans' }}" \
              --name "${SARIF_SRC}" \
              --file "${SARIF_SRC}" \
              --overwrite true
            echo "Trivy SARIF uploaded successfully"

      - name: Upload CodeQL SARIF to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' && env.CODEQL_SARIF_OUT != '' && hashFiles(env.CODEQL_SARIF_OUT) != '' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            az cloud show

            CN="${{ steps.cfg.outputs.cn_scan || 'scans' }}"
            test -s "${CODEQL_SARIF_OUT}"

            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "$CN" \
              --name "${CODEQL_SARIF_OUT}" \
              --file "${CODEQL_SARIF_OUT}" \
              --overwrite true

            echo "âœ… Uploaded CodeQL SARIF: ${CODEQL_SARIF_OUT}"
          
      - name: Upload CodeQL SARIF signature to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' && env.CODEQL_SARIF_OUT != '' && hashFiles(format('{0}.sig', env.CODEQL_SARIF_OUT)) != '' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment

            CN="${{ steps.cfg.outputs.cn_scan || 'scans' }}"
            SIG="${CODEQL_SARIF_OUT}.sig"
            test -s "$SIG"

            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "$CN" \
              --name "$SIG" \
              --file "$SIG" \
              --overwrite true

            echo "âœ… Uploaded CodeQL SARIF signature: $SIG"

      - name: Upload Trivy SARIF signature to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' && hashFiles(format('{0}.sig', env.SARIF_SRC)) != '' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            SIG="${SARIF_SRC}.sig"
            test -s "$SIG"
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "${{ steps.cfg.outputs.cn_scan || 'scans' }}" \
              --name "$SIG" \
              --file "$SIG"
            echo "Trivy SARIF signature uploaded successfully"

      - name: Upload CodeQL Database to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' && hashFiles('codeql-export/codeql-database-python.tar.gz') != '' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            echo "Copying CodeQL database to final location..."
            cp "codeql-export/codeql-database-python.tar.gz" "${CODEQL_DB_FILE}"
            
            echo "Uploading CodeQL database to Azure Storage..."
            az cloud set --name AzureUSGovernment
            az cloud show
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "${{ steps.cfg.outputs.cn_scan || 'scans' }}" \
              --name "${CODEQL_DB_FILE}" \
              --file "${CODEQL_DB_FILE}" \
              --overwrite true
            echo "CodeQL database uploaded successfully"
            
            # Store URL for later use
            CODEQL_DB_URL="https://$AZURE_STORAGE_ACCOUNT.blob.core.windows.net/${{ steps.cfg.outputs.cn_scan || 'scans' }}/${CODEQL_DB_FILE}"
            echo "CODEQL_DB_URL=$CODEQL_DB_URL" >> $GITHUB_ENV

      - name: Cosign sign CodeQL DB tarball
        if: ${{ hashFiles(env.CODEQL_DB_FILE) != '' }}
        env:
          COSIGN_YES: "true"
        run: |
          set -euo pipefail
          ARTIFACT="${CODEQL_DB_FILE}"
          cosign sign-blob --key cosign.key --output-signature "${ARTIFACT}.sig" "${ARTIFACT}"
          ls -l "${ARTIFACT}.sig"
          echo "CODE QL Artifact signed succesfully"

      - name: Upload CodeQL DB signature to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' && hashFiles(format('{0}.sig', env.CODEQL_DB_FILE)) != '' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            CN="${{ steps.cfg.outputs.cn_scan || 'scans' }}"
            SIG="${CODEQL_DB_FILE}.sig"
            test -s "$SIG"
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "$CN" \
              --name "$SIG" \
              --file "$SIG" 
            echo "Succesfully uploaded Code QL signature"

      # ---------- Upload each artifact as a single file ----------
      - name: Upload SBOM artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(env.SBOM_SRC) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.SBOM_SRC }}

      - name: Upload Trivy JSON artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(env.TRIVY_SRC) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: trivy-json-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.TRIVY_SRC }}

      - name: Upload Trivy SARIF artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(env.SARIF_SRC) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: trivy-sarif-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.SARIF_SRC }}

      - name: Upload CodeQL Database artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles('codeql-export/codeql-database-python.tar.gz') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: codeql-database-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: codeql-export/codeql-database-python.tar.gz

      - name: Upload CodeQL SARIF artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles('codeql-export/*.sarif') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: codeql-sarif-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: codeql-export/*.sarif

      - name: Upload Docker Inspect artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(env.INSPECT_SRC) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: docker-inspect-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.INSPECT_SRC }}

      # ---------- Build RUN JSON AFTER Azure uploads & Deploy ----------
      - name: Ensure jq present (for RUN JSON)
        run: jq --version || (sudo apt-get update -y && sudo apt-get install -y jq)

      - name: Build run JSON payload (fixed jq program)
        id: build_run_json
        run: |
          set -euo pipefail
          SBOM_LINK="${SBOM_URL:-}"
          TRIVY_LINK="${TRIVY_URL:-}"
          CODEQL_LINK="${CODEQL_DB_URL:-}"
          jq -n \
            --arg id              "${RUN_ID}" \
            --arg projectName     "${PROJECT_NAME}" \
            --arg runNumber       "${RUN_NUMBER}" \
            --arg repo            "${GITHUB_REPOSITORY}" \
            --arg workflow        "${GITHUB_WORKFLOW}" \
            --arg ref             "${GITHUB_REF}" \
            --arg sha             "${GITHUB_SHA}" \
            --arg timestamp       "${RUN_TIMESTAMP}" \
            --arg actionsRunUrl   "${ACTIONS_RUN_URL}" \
            --arg acr             "${ACR_LOGIN_SERVER}" \
            --arg imageName       "${IMAGE_NAME}" \
            --arg imageTag        "${IMAGE_TAG}" \
            --arg imageDigest     "${IMAGE_DIGEST}" \
            --arg sbomFile        "${SBOM_FILE}" \
            --arg trivyFile       "${TRIVY_FILE}" \
            --arg sarifFile       "${SARIF_FILE}" \
            --arg codeqlDbFile    "${CODEQL_DB_FILE}" \
            --arg sbomUrl         "${SBOM_LINK}" \
            --arg trivyUrl        "${TRIVY_LINK}" \
            --arg codeqlUrl       "${CODEQL_LINK}" \
            --arg aciName         "${AZURE_CONTAINER_NAME}" \
            --arg aciRg           "${AZURE_RESOURCE_GROUP}" \
            --arg aciUrl          "${ACI_URL:-}" \
            --arg cosignStatus    "${COSIGN_VERIFY_STATUS:-unknown}" \
            --arg sevLevels       "${{ steps.cfg.outputs.scan_levels }}" \
            --arg failLevels      "${{ steps.cfg.outputs.fail_levels }}" \
            --argjson ignoreUnfix ${{ steps.cfg.outputs.ignore_unfixed }} \
            --argjson totalFindings ${TRIVY_FINDINGS_TOTAL:-0} \
            --argjson failFindings  ${TRIVY_FINDINGS_FAILSET:-0} \
            '
            def azure_links:
              if (($sbomUrl|length) > 0 or ($trivyUrl|length) > 0 or ($codeqlUrl|length) > 0)
              then { sbom: $sbomUrl, trivy: $trivyUrl, codeqlDb: $codeqlUrl }
              else null
              end;

            {
              id: $id,
              projectName: $projectName,
              createdAt: $timestamp,
              repository: $repo,
              workflow: $workflow,
              ref: $ref,
              commitSha: $sha,
              run: { id: $id, number: $runNumber, url: $actionsRunUrl },
              image: { registry: $acr, name: $imageName, tag: $imageTag, digest: $imageDigest },
              artifacts: {
                azure: azure_links,
                files: { sbom: $sbomFile, trivy: $trivyFile, sarif: $sarifFile, codeqlDb: $codeqlDbFile }
              },
              assessment: {
                cosign: { verifyStatus: $cosignStatus },
                trivy: {
                  scanSeverities: $sevLevels,
                  ignoreUnfixed: $ignoreUnfix,
                  failSeverities: $failLevels,
                  findings: { total: $totalFindings, failSet: $failFindings }
                }
              },
              deployment: { aci: { name: $aciName, resourceGroup: $aciRg, url: $aciUrl } }
            }' > "${RUNJSON_SRC}"
          test -s "${RUNJSON_SRC}"
          ls -l "${RUNJSON_SRC}"

      - name: Cosign sign RUN JSON
        if: ${{ hashFiles(env.RUNJSON_SRC) != '' }}
        env:
          COSIGN_YES: "true"
        run: |
          set -euo pipefail
          ARTIFACT="${RUNJSON_SRC}"
          cosign sign-blob --key cosign.key --output-signature "${ARTIFACT}.sig" "${ARTIFACT}"
          ls -l "${ARTIFACT}.sig"
          

      - name: Upload RUN JSON to Azure Storage (flat name)
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            az cloud show
            echo "Uploading run.json to Azure Storage..."
            test -s "${RUNJSON_SRC}" || { echo "Error: ${RUNJSON_SRC} not found or empty"; pwd; ls -la; exit 2; }
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "${{ steps.cfg.outputs.cn_runs || 'runs' }}" \
              --name "${RUNJSON_SRC}" \
              --file "${RUNJSON_SRC}" \
              --overwrite true
            echo "run.json uploaded successfully"

      - name: Upload RUN JSON signature to Azure Storage
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' && hashFiles(format('{0}.sig', env.RUNJSON_SRC)) != '' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment
            SIG="${RUNJSON_SRC}.sig"
            test -s "$SIG"
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "${{ steps.cfg.outputs.cn_runs || 'runs' }}" \
              --name "$SIG" \
              --file "$SIG" 
            echo "Run Json signature uploaded successfully"


      - name: Upload RUN JSON artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(env.RUNJSON_SRC) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: swft-run-json-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.RUNJSON_SRC }}

      - name: Upload SBOM signature artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(format('{0}.sig', env.SBOM_SRC)) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-sig-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.SBOM_SRC }}.sig

      - name: Upload Trivy JSON signature artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(format('{0}.sig', env.TRIVY_SRC)) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: trivy-json-sig-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.TRIVY_SRC }}.sig

      - name: Upload Trivy SARIF signature artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(format('{0}.sig', env.SARIF_SRC)) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: trivy-sarif-sig-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.SARIF_SRC }}.sig

      - name: Upload Docker inspect signature artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(format('{0}.sig', env.INSPECT_SRC)) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: docker-inspect-sig-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.INSPECT_SRC }}.sig

      - name: Upload CodeQL DB signature artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(format('{0}.sig', env.CODEQL_DB_FILE)) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: codeql-db-sig-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.CODEQL_DB_FILE }}.sig

      - name: Upload RUN JSON signature artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles(format('{0}.sig', env.RUNJSON_SRC)) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: run-json-sig-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ env.RUNJSON_SRC }}.sig


      - name: Azure upload summary
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        run: |
          {
            echo "### Azure uploads"
            echo ""
            echo "- SBOM:  ${SBOM_URL:-'(n/a)'}"
            echo "- Trivy: ${TRIVY_URL:-'(n/a)'}"
            echo "- CodeQL Database: ${CODEQL_DB_URL:-'(n/a)'}"
            echo "- Run JSON: ${RUN_JSON_URL:-'(n/a)'}"
            echo ""
            echo "### CodeQL Database Usage"
            echo ""
            echo "The CodeQL database has been exported and uploaded alongside Trivy results."
            echo "To query the database later:"
            echo ""
            echo '```bash'
            echo "# Download the database"
            echo "wget '${CODEQL_DB_URL:-'<codeql-db-url>'}' -O codeql-database-python.tar.gz"
            echo ""
            echo "# Extract the database"
            echo "tar -xzf codeql-database-python.tar.gz"
            echo ""
            echo "# Run custom CodeQL queries"
            echo "codeql database analyze ./codeql-database-python --format=sarif-latest --output=custom-results.sarif -- query.ql"
            echo ""
            echo "# Or run standard query suites"
            echo "codeql database analyze ./codeql-database-python --format=sarif-latest --output=security-results.sarif python-security-and-quality.qls"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

  final-assessment:
    name: Final Security Assessment - CTF Engine
    needs: build-and-upload
    runs-on: self-hosted
    env:
      AZURE_AUTHORITY_HOST: https://login.microsoftonline.us/
    if: success()  # Only run if previous job succeeds
    defaults: { run: { shell: bash } }
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
        env:
          DOTNET_INSTALL_DIR: ${{ runner.temp }}/.dotnet

      # Have to reinstall cosign to sign artifacts in the Final assesment job
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.9.0

      - name: Decode Cosign keys
        run: |
          set -euo pipefail
          echo "${{ secrets.COSIGN_KEY_B64 }}" | base64 -d > cosign.key
          echo "${{ secrets.COSIGN_PUB_KEY_B64 }}" | base64 -d > cosign.pub
          chmod 600 cosign.key
          chmod 644 cosign.pub

      # Download artifacts from previous job
      - name: Download CodeQL SARIF
        uses: actions/download-artifact@v4
        with:
          name: codeql-sarif-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: security-reports/
        continue-on-error: true

      - name: Download Trivy JSON
        uses: actions/download-artifact@v4
        with:
          name: trivy-json-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: security-reports/
        continue-on-error: true

      - name: Download Trivy SARIF
        uses: actions/download-artifact@v4
        with:
          name: trivy-sarif-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: security-reports/
        continue-on-error: true
      
      - name: Download Docker Inspect
        uses: actions/download-artifact@v4
        with:
          name: docker-inspect-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: security-reports/
        continue-on-error: true

      # Fetch SonarQube results via API
      - name: Download SonarQube Results
        run: |
          mkdir -p security-reports
          curl -u "${{ secrets.SONAR_TOKEN }}:" \
            "${{ secrets.SONAR_HOST_URL }}/api/issues/search?componentKeys=swft-python&types=VULNERABILITY,BUG,CODE_SMELL&statuses=OPEN" \
            -o security-reports/sonarqube.json
        continue-on-error: true

      - name: Cosign sign SonarQube JSON
        if: ${{ hashFiles('security-reports/sonarqube.json') != '' }}
        env:
          COSIGN_YES: "true"
        run: |
          set -euo pipefail
          ARTIFACT="security-reports/sonarqube.json"
          cosign sign-blob --key cosign.key --output-signature "${ARTIFACT}.sig" "${ARTIFACT}"
          ls -l "${ARTIFACT}.sig"


      #Upload Sonarqube results to scan container
      - name: Upload SonarQube JSON to Azure Storage
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_to_azure == true || github.event_name != 'workflow_dispatch' }}
        uses: azure/CLI@v2
        env:
          AZURE_STORAGE_ACCOUNT: ${{ env.AZURE_STORAGE_ACCOUNT }}
          AZ_SAS_TOKEN_STORAGE: ${{ env.AZ_SAS_TOKEN_STORAGE }}
          PROJECT_NAME: ${{ env.PROJECT_NAME }}
          RUN_ID: ${{ env.RUN_ID }}
        with:
          inlineScript: |
            set -euo pipefail

            az cloud set --name AzureUSGovernment
            az cloud show

            SONAR_SRC="security-reports/sonarqube.json"
            SONAR_BLOB="${PROJECT_NAME}_${RUN_ID}_sonarqube_scan.json"

            if [ ! -f "$SONAR_SRC" ]; then
              echo "::warning::SonarQube report not found, skipping upload"
              exit 0
            fi

            echo "Uploading SonarQube report to Azure..."
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "scans" \
              --name "$SONAR_BLOB" \
              --file "$SONAR_SRC" \
              --overwrite true
            
            echo "SonarQube report uploaded to Azure"

      - name: Upload SonarQube signature to Azure Storage
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_to_azure == true || github.event_name != 'workflow_dispatch' }}
        uses: azure/CLI@v2
        env:
          AZURE_STORAGE_ACCOUNT: ${{ env.AZURE_STORAGE_ACCOUNT }}
          AZ_SAS_TOKEN_STORAGE: ${{ env.AZ_SAS_TOKEN_STORAGE }}
          PROJECT_NAME: ${{ env.PROJECT_NAME }}
          RUN_ID: ${{ env.RUN_ID }}
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment

            SIG="security-reports/sonarqube.json.sig"
            test -s "$SIG"

            SONAR_BLOB="${PROJECT_NAME}_${RUN_ID}_sonarqube_scan.json"
            SIG_BLOB="${SONAR_BLOB}.sig"

            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "scans" \
              --name "$SIG_BLOB" \
              --file "$SIG" \
              --overwrite true

            echo "Successfully uploaded SonarQube signature"


      - name: Checkout SCAI CTF Engine
        uses: actions/checkout@v4
        with:
          repository: ISD-AI-Hero/SCAI_CTF_Engine
          path: SCAI_CTF_Engine
          token: ${{ secrets.SCAI_CTF_PAT }}

      # Build SCAI CTF Engine
      - name: Build SCAI CTF Engine
        run: |
          cd SCAI_CTF_Engine/SCAI.CTF.Engine
          dotnet publish -c Release -o ../../scai-engine

      - name: Dump identity-related env (safe)
        run: |
          set -euo pipefail
          echo "=== Identity env (filtered) ==="
          env | sort | egrep -i '^(AZURE_|ACTIONS_ID_TOKEN|OIDC|MSI|IDENTITY|IMDS|DOTNET_|ASPNETCORE_)' || true

      - name: Force fresh Azure CLI auth (Gov) for Key Vault
        env:
          AZURE_CONFIG_DIR: ${{ runner.temp }}/azure-config
        run: |
          set -euo pipefail
          rm -rf "$AZURE_CONFIG_DIR"
          mkdir -p "$AZURE_CONFIG_DIR"

          az cloud set --name AzureUSGovernment
          az cloud show --query "{name:name, ad:endpoints.activeDirectory}" -o jsonc

          az login --identity -o none

          echo "=== KV token smoke test ==="
          az account get-access-token \
            --resource https://vault.usgovcloudapi.net \
            --query "{tenant:tenant, expiresOn:expiresOn}" -o jsonc

      # Run Final Assessment
      - name: Run SCAI CTF Engine Final Assessment
        env:
          SCAI_OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SCAI_OPENAI_MODEL: ${{ secrets.OPENAI_MODEL || 'gpt-4o' }}
          SCAI_OPENAI_ENDPOINT: ${{ secrets.OPENAI_ENDPOINT }}
          #Because there are Github Actions OIDC env variables, we need to disable workload identity this is what is happening with the 3 below
          AZURE_AUTHORITY_HOST: https://login.microsoftonline.us/
          AZURE_CONFIG_DIR: ${{ runner.temp }}/azure-config
          AZURE_IDENTITY_DISABLE_WORKLOAD_IDENTITY: "true"
        run: |
          echo "=== Downloaded security reports ==="
          ls -la security-reports/
          echo ""
          
          # CodeQL SARIF is extracted from the artifact zip
          CODEQL_SARIF=$(ls security-reports/*.sarif 2>/dev/null | grep -v trivy | head -1)
          
          if [ -z "$CODEQL_SARIF" ]; then
            echo "âš ï¸ No CodeQL SARIF file found, creating empty placeholder"
            CODEQL_SARIF="security-reports/empty-codeql.sarif"
            echo '{"version":"2.1.0","runs":[]}' > "$CODEQL_SARIF"
          else
            echo "âœ“ Found CodeQL SARIF: $CODEQL_SARIF"
          fi
          
          TRIVY_JSON=$(ls security-reports/*trivy-report.json 2>/dev/null | head -1)
          if [ -z "$TRIVY_JSON" ]; then
            echo "âš ï¸ No Trivy JSON file found, creating empty placeholder"
            TRIVY_JSON="security-reports/empty-trivy.json"
            echo '{"Results":[]}' > "$TRIVY_JSON"
          else
            echo "âœ“ Using Trivy JSON: $TRIVY_JSON"
          fi

          echo "âœ“ Using SonarQube JSON: security-reports/sonarqube.json"
          echo ""

          rm -rf "$AZURE_CONFIG_DIR"
          mkdir -p "$AZURE_CONFIG_DIR"

          az cloud set --name AzureUSGovernment
          az login --identity -o none

          echo "Cloud: $(az cloud show --query name -o tsv)"
          az account get-access-token --resource https://vault.usgovcloudapi.net --query tenant -o tsv

          
          ./scai-engine/SCAI.CTF.Engine \
            --CodeQLFilePath "$CODEQL_SARIF" \
            --SonarqubeFilePath security-reports/sonarqube.json \
            --TrivyFilePath "$TRIVY_JSON" \
            --OutputPath security-reports \
            --BuildId ${{ github.run_id }} \
            --Project ${{ env.PROJECT_NAME }}

      # Parse and check risk level
      - name: Parse Final Assessment
        id: assessment
        run: |
          FINAL_ASSESSMENT=$(ls -t security-reports/final_assessment_*.json | head -1)
          
          if [ -f "$FINAL_ASSESSMENT" ]; then
            RISK_LEVEL=$(jq -r '.RiskLevel' "$FINAL_ASSESSMENT")
            VULN_COUNT=$(jq '.Vulnerabilities | length' "$FINAL_ASSESSMENT")
            CRITICAL_COUNT=$(jq '[.Vulnerabilities[] | select(.RiskLevel == "Critical")] | length' "$FINAL_ASSESSMENT")
            HIGH_COUNT=$(jq '[.Vulnerabilities[] | select(.RiskLevel == "High")] | length' "$FINAL_ASSESSMENT")
            
            echo "risk_level=$RISK_LEVEL" >> $GITHUB_OUTPUT
            echo "vuln_count=$VULN_COUNT" >> $GITHUB_OUTPUT
            echo "critical_count=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
            echo "high_count=$HIGH_COUNT" >> $GITHUB_OUTPUT
            echo "assessment_file=$FINAL_ASSESSMENT" >> $GITHUB_OUTPUT
            
            echo "::notice::Final Risk Level: $RISK_LEVEL"
            echo "::notice::Total Vulnerabilities: $VULN_COUNT (Critical: $CRITICAL_COUNT, High: $HIGH_COUNT)"
          else
            echo "::error::Final assessment file not found!"
            exit 1
          fi

      - name: Cosign sign Final Assessment JSON
        if: ${{ steps.assessment.outputs.assessment_file != '' }}
        env:
          COSIGN_YES: "true"
        run: |
          set -euo pipefail
          ARTIFACT="${{ steps.assessment.outputs.assessment_file }}"
          cosign sign-blob --key cosign.key --output-signature "${ARTIFACT}.sig" "${ARTIFACT}"
          ls -l "${ARTIFACT}.sig"
          echo "Signed Final Assesment"


      # Upload final assessment to Azure Storage
      - name: Upload Final Assessment to Azure Storage
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_to_azure == true || github.event_name != 'workflow_dispatch' }}
        uses: azure/CLI@v2
        env:
          AZURE_STORAGE_ACCOUNT: ${{ env.AZURE_STORAGE_ACCOUNT }}
          AZ_SAS_TOKEN_STORAGE: ${{ env.AZ_SAS_TOKEN_STORAGE }}
          PROJECT_NAME: ${{ env.PROJECT_NAME }}
          RUN_ID: ${{ env.RUN_ID }}
        with:
          inlineScript: |
            set -euo pipefail

            #Set to goverment cloud
            az cloud set --name AzureUSGovernment
            az cloud show
            
            # Debug environment variables
            echo "=== Debugging Azure Environment Variables ==="
            echo "AZURE_STORAGE_ACCOUNT: ${AZURE_STORAGE_ACCOUNT:-'NOT SET'}"
            echo "AZ_SAS_TOKEN_STORAGE length: ${#AZ_SAS_TOKEN_STORAGE}"
            echo "PROJECT_NAME: ${PROJECT_NAME:-'NOT SET'}"
            echo "RUN_ID: ${RUN_ID:-'NOT SET'}"
            echo ""
            
            ASSESSMENT_FILE="${{ steps.assessment.outputs.assessment_file }}"
            ASSESSMENT_NAME="final_assessment_${PROJECT_NAME}_${RUN_ID}.json"
            
            echo "Assessment File: $ASSESSMENT_FILE"
            echo "Assessment Name: $ASSESSMENT_NAME"
            
            # Verify file exists
            if [ ! -f "$ASSESSMENT_FILE" ]; then
              echo "::error::Assessment file not found: $ASSESSMENT_FILE"
              exit 1
            fi
            
            echo "File size: $(stat -f%z "$ASSESSMENT_FILE" 2>/dev/null || stat -c%s "$ASSESSMENT_FILE" 2>/dev/null || echo 'unknown')"
            echo ""
            
            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "scans" \
              --name "$ASSESSMENT_NAME" \
              --file "$ASSESSMENT_FILE" \
              --overwrite true
            
            echo "âœ… Final assessment uploaded successfully"
        continue-on-error: false

      - name: Upload Final Assessment signature to Azure Storage
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_to_azure == true || github.event_name != 'workflow_dispatch' }}
        uses: azure/CLI@v2
        env:
          AZURE_STORAGE_ACCOUNT: ${{ env.AZURE_STORAGE_ACCOUNT }}
          AZ_SAS_TOKEN_STORAGE: ${{ env.AZ_SAS_TOKEN_STORAGE }}
          PROJECT_NAME: ${{ env.PROJECT_NAME }}
          RUN_ID: ${{ env.RUN_ID }}
        with:
          inlineScript: |
            set -euo pipefail
            az cloud set --name AzureUSGovernment

            ARTIFACT_NAME="final_assessment_${PROJECT_NAME}_${RUN_ID}.json"
            SIG_FILE="${{ steps.assessment.outputs.assessment_file }}.sig"
            SIG_NAME="${ARTIFACT_NAME}.sig"
            test -s "$SIG_FILE"

            az storage blob upload \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --sas-token "$AZ_SAS_TOKEN_STORAGE" \
              --container-name "scans" \
              --name "$SIG_NAME" \
              --file "$SIG_FILE" 
            
            echo "Final Assesment signature uploaded succesfully"


      # Upload as GitHub artifact
      - name: Upload Final Assessment Artifact
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_artifacts == true || github.event_name != 'workflow_dispatch' }}
        uses: actions/upload-artifact@v4
        with:
          name: final-assessment-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ steps.assessment.outputs.assessment_file }}
          retention-days: 90

      - name: Upload Final Assessment Signature Artifact
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_artifacts == true || github.event_name != 'workflow_dispatch' }}
        uses: actions/upload-artifact@v4
        with:
          name: final-assessment-sig-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: ${{ steps.assessment.outputs.assessment_file }}.sig
          retention-days: 90


      # Create summary
      - name: Generate Assessment Summary
        if: always()
        run: |
          ASSESSMENT_FILE="${{ steps.assessment.outputs.assessment_file }}"
          
          if [ -f "$ASSESSMENT_FILE" ]; then
            DETERMINATION=$(jq -r '.Determination' "$ASSESSMENT_FILE" | head -c 500)
            
            {
              echo "## ðŸ”’ AI-Powered Security Assessment"
              echo ""
              echo "**Overall Risk Level:** \`${{ steps.assessment.outputs.risk_level }}\`"
              echo "**Project:** ${{ env.PROJECT_NAME }}"
              echo "**Build:** ${{ env.RUN_ID }}"
              echo ""
              echo "### Vulnerability Summary"
              echo "- **Total Vulnerabilities:** ${{ steps.assessment.outputs.vuln_count }}"
              echo "- **Critical:** ${{ steps.assessment.outputs.critical_count }}"
              echo "- **High:** ${{ steps.assessment.outputs.high_count }}"
              echo ""
              echo "### AI Assessment Preview"
              echo "\`\`\`"
              echo "$DETERMINATION..."
              echo "\`\`\`"
              echo ""
              echo "ðŸ“Š [Full Assessment Report](${FINAL_ASSESSMENT_URL:-'See artifacts'})"
            } >> $GITHUB_STEP_SUMMARY
          fi

      # Optional: Fail on Critical risk (only for push events, not manual runs)
      - name: Enforce Critical Risk Policy
        if: steps.assessment.outputs.risk_level == 'Critical' && github.event_name == 'push'
        run: |
          echo "::error::ðŸš¨ Critical security vulnerabilities detected! Deployment blocked."
          echo "::error::Review the final assessment report before proceeding."
          exit 1
