name: SWFT Container CI/CD

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      project_name:
        description: "Logical Project Name for SWFT tracking"
        type: string
        default: "swft-demo"
      upload_to_azure:
        description: "Upload SBOM/scan/run JSON to Azure Storage (RBAC via azure/login)"
        type: boolean
        default: true
      upload_artifacts:
        description: "Upload SBOM/scan/run JSON as GitHub Artifacts"
        type: boolean
        default: true
      storage_container_sboms:
        description: "Azure container for SBOMs"
        type: string
        default: "sboms"
      storage_container_scans:
        description: "Azure container for vulnerability scans"
        type: string
        default: "scans"
      storage_container_runs:
        description: "Azure container for run JSON payloads"
        type: string
        default: "runs"
      fail_on_trivy:
        description: "Fail the workflow if Trivy finds vulnerabilities (manual runs only)"
        type: boolean
        default: false
      trivy_severity:
        description: "Severities to gate on (comma-separated)"
        type: string
        default: "HIGH,CRITICAL"
      trivy_ignore_unfixed:
        description: "Ignore unfixed vulnerabilities"
        type: boolean
        default: true
      fail_on_cosign_verify:
        description: "Fail the workflow if Cosign verify fails"
        type: boolean
        default: true
      fail_on_severities:
        description: "Severities that trigger a FAIL (comma-separated)"
        type: string
        default: "CRITICAL"

permissions:
  contents: read
  id-token: write
  security-events: write

env:
  # Registry
  ACR_LOGIN_SERVER:     ${{ secrets.ACR_LOGIN_SERVER }}
  ACR_USERNAME:         ${{ secrets.ACR_USERNAME }}
  ACR_PASSWORD:         ${{ secrets.ACR_PASSWORD }}
  IMAGE_NAME:           fastapi-demo
  IMAGE_TAG:            ${{ secrets.IMAGE_TAG }}

  # Azure targets
  AZURE_RESOURCE_GROUP: demo-swft-cicd
  AZURE_CONTAINER_NAME: swft-fastapi
  AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}

  # Defaults for push runs
  TRIVY_SEVERITY:       ${{ vars.TRIVY_SEVERITY || 'HIGH,CRITICAL' }}
  TRIVY_IGNORE_UNFIXED: ${{ vars.TRIVY_IGNORE_UNFIXED || 'true' }}

  # Names & IDs
  PROJECT_NAME: ${{ github.event_name == 'workflow_dispatch' && inputs.project_name || vars.PROJECT_NAME || github.event.repository.name }}
  RUN_ID:       ${{ github.run_id }}
  RUN_NUMBER:   ${{ github.run_number }}

  # FIXED artifact filenames (don’t change)
  SBOM_SRC:     sbom.cyclonedx.json
  TRIVY_SRC:    trivy-report.json
  SARIF_SRC:    trivy-results.sarif
  DEPLOY_SRC:   aci-endpoint.txt
  RUNJSON_SRC:  run.json

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults: { run: { shell: bash } }

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (Service Principal, AzureCloud)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          environment: azureCloud

      - name: Derive pretty names & timestamp (for Azure + RUN JSON only)
        run: |
          set -euo pipefail
          FILE_PREFIX="${PROJECT_NAME}-${RUN_ID}"
          echo "FILE_PREFIX=$FILE_PREFIX" >> $GITHUB_ENV
          echo "SBOM_FILE=${FILE_PREFIX}-sbom.json"     >> $GITHUB_ENV
          echo "TRIVY_FILE=${FILE_PREFIX}-trivy.json"   >> $GITHUB_ENV
          echo "SARIF_FILE=${FILE_PREFIX}-trivy.sarif"  >> $GITHUB_ENV
          echo "DEPLOY_FILE=${FILE_PREFIX}-deploy.txt"  >> $GITHUB_ENV
          echo "RUN_JSON_FILE=${FILE_PREFIX}-run.json"  >> $GITHUB_ENV
          echo "BLOB_PREFIX=${FILE_PREFIX}"             >> $GITHUB_ENV
          echo "ACTIONS_RUN_URL=https://github.com/${GITHUB_REPOSITORY}/actions/runs/${RUN_ID}" >> $GITHUB_ENV
          date -u +%FT%TZ | xargs -I{} echo "RUN_TIMESTAMP={}" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ACR_LOGIN_SERVER }}
          username: ${{ env.ACR_USERNAME }}
          password: ${{ env.ACR_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Pull image for local scan
        run: docker pull "${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

      - name: Get image digest
        run: |
          set -euo pipefail
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${ACR_LOGIN_SERVER}/${IMAGE_NAME}:${IMAGE_TAG}" | awk -F'@' '{print $2}')
          echo "IMAGE_DIGEST=$DIGEST" >> $GITHUB_ENV

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.9.0

      - name: Decode Cosign keys
        run: |
          set -euo pipefail
          echo "${{ secrets.COSIGN_KEY_B64 }}" | base64 -d > cosign.key
          chmod 600 cosign.key
          echo "${{ secrets.COSIGN_PUB_KEY_B64 }}" | base64 -d > cosign.pub
          chmod 644 cosign.pub

      - name: Sign image (by digest, no tlog)
        run: |
          set -euo pipefail
          REF="${ACR_LOGIN_SERVER}/${IMAGE_NAME}@${IMAGE_DIGEST}"
          echo "Signing $REF"
          cosign sign \
            --key cosign.key \
            --tlog-upload=false \
            "$REF"

      - name: Verify image signature (by digest; ignore tlog)
        env:
          POLICY_FAIL_ON_VERIFY: ${{ github.event_name == 'workflow_dispatch' && inputs.fail_on_cosign_verify || 'true' }}
        run: |
          set +e
          REF="${ACR_LOGIN_SERVER}/${IMAGE_NAME}@${IMAGE_DIGEST}"
          cosign verify \
            --key cosign.pub \
            --insecure-ignore-tlog \
            "$REF" >/tmp/cosign.verify 2>&1
          STATUS=$?
          set -e
          if [ $STATUS -eq 0 ]; then
            echo "COSIGN_VERIFY_STATUS=passed" >> $GITHUB_ENV
          else
            echo "COSIGN_VERIFY_STATUS=failed" >> $GITHUB_ENV
            echo "--- cosign verify output ---"
            cat /tmp/cosign.verify || true
            echo "---------------------------"
            if [ "$POLICY_FAIL_ON_VERIFY" = "true" ]; then exit 1; fi
          fi


      # === GENERATE FILES WITH OFFICIAL ACTIONS (fixed names) ===
      - name: Generate SBOM (Syft via Anchore)
        uses: anchore/sbom-action@v0.20.1
        with:
          image:        ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format:       cyclonedx-json
          output-file:  ${{ env.SBOM_SRC }}
          upload-artifact: false

      - name: Verify SBOM exists
        run: |
          set -euo pipefail
          ls -l || true
          test -s "${SBOM_SRC}" || { echo "SBOM not created: ${SBOM_SRC}"; exit 2; }

      - name: Run Trivy vulnerability scanner (JSON)
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_USERNAME: ${{ env.ACR_USERNAME }}
          TRIVY_PASSWORD: ${{ env.ACR_PASSWORD }}
        with:
          version: 'v0.66.0'
          scan-type: 'image'
          image-ref: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format: 'json'
          output: ${{ env.TRIVY_SRC }}
          severity: ${{ github.event_name == 'workflow_dispatch' && inputs.trivy_severity || env.TRIVY_SEVERITY }}
          ignore-unfixed: ${{ github.event_name == 'workflow_dispatch' && inputs.trivy_ignore_unfixed || env.TRIVY_IGNORE_UNFIXED }}
          scanners: 'vuln'
          exit-code: '0'

      - name: Verify Trivy JSON exists
        run: |
          set -euo pipefail
          ls -l || true
          test -s "${TRIVY_SRC}" || { echo "Trivy JSON not created: ${TRIVY_SRC}"; exit 2; }

      - name: Generate Trivy SARIF
        uses: aquasecurity/trivy-action@0.33.1
        with:
          version: 'v0.66.0'
          scan-type: 'image'
          image-ref: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: ${{ env.SARIF_SRC }}
          severity: ${{ github.event_name == 'workflow_dispatch' && inputs.trivy_severity || env.TRIVY_SEVERITY }}
          ignore-unfixed: ${{ github.event_name == 'workflow_dispatch' && inputs.trivy_ignore_unfixed || env.TRIVY_IGNORE_UNFIXED }}
          scanners: 'vuln'
          exit-code: '0'

      - name: Verify Trivy SARIF exists
        run: |
          set -euo pipefail
          ls -l || true
          test -s "${SARIF_SRC}" || { echo "Trivy SARIF not created: ${SARIF_SRC}"; exit 2; }

      - name: Ensure jq present (policy step needs it)
        run: jq --version || (sudo apt-get update -y && sudo apt-get install -y jq)


      - name: Enforce Trivy policy (fail only on selected severities)
        env:
          POLICY_FAIL_ON_TRIVY:  ${{ github.event_name == 'workflow_dispatch' && inputs.fail_on_trivy || (vars.FAIL_ON_TRIVY || 'false') }}
          SCAN_LEVELS:           ${{ github.event_name == 'workflow_dispatch' && inputs.trivy_severity || env.TRIVY_SEVERITY }}
          FAIL_LEVELS:           ${{ github.event_name == 'workflow_dispatch' && inputs.fail_on_severities || 'CRITICAL' }}
        run: |
          set -euo pipefail

          # Sanity: show what we’re gating on
          echo "SCAN_LEVELS=$SCAN_LEVELS"
          echo "FAIL_LEVELS=$FAIL_LEVELS"
          echo "POLICY_FAIL_ON_TRIVY=$POLICY_FAIL_ON_TRIVY"

          # Count findings in the scan (based on SCAN_LEVELS passed to Trivy)
          TOTAL_COUNT=$(jq --arg sev "$SCAN_LEVELS" '
            [.Results[].Vulnerabilities[]? as $v
              | ($sev | split(",")) as $levels
              | select($levels | index($v.Severity))
            ] | length' "${TRIVY_SRC}")

          # Count only the severities that should FAIL the run
          FAIL_COUNT=$(jq --arg sev "$FAIL_LEVELS" '
            [.Results[].Vulnerabilities[]? as $v
              | ($sev | split(",")) as $levels
              | select($levels | index($v.Severity))
            ] | length' "${TRIVY_SRC}")

          # Optional: per-severity tallies (handy for the summary)
          COUNT_CRIT=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' "${TRIVY_SRC}")
          COUNT_HIGH=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="HIGH")]     | length' "${TRIVY_SRC}")
          COUNT_MED=$(jq  '[.Results[].Vulnerabilities[]? | select(.Severity=="MEDIUM")]   | length' "${TRIVY_SRC}") || true
          COUNT_LOW=$(jq  '[.Results[].Vulnerabilities[]? | select(.Severity=="LOW")]      | length' "${TRIVY_SRC}") || true

          echo "TRIVY_FINDINGS_TOTAL=$TOTAL_COUNT" >> $GITHUB_ENV
          echo "TRIVY_FINDINGS_FAILSET=$FAIL_COUNT" >> $GITHUB_ENV

          {
            echo "### Trivy Policy"
            echo "- Scan severities (reported): $SCAN_LEVELS"
            echo "- Fail severities (gated):    $FAIL_LEVELS"
            echo "- Findings (total in scan):   $TOTAL_COUNT"
            echo "- Findings (in fail set):     $FAIL_COUNT"
            echo "- Breakdown: CRITICAL=$COUNT_CRIT, HIGH=$COUNT_HIGH, MEDIUM=$COUNT_MED, LOW=$COUNT_LOW"
            echo "- Fail on Trivy:              $POLICY_FAIL_ON_TRIVY"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "$POLICY_FAIL_ON_TRIVY" = "true" ] && [ "$FAIL_COUNT" -gt 0 ]; then
            echo "Failing due to findings in fail set ($FAIL_LEVELS): $FAIL_COUNT"
            exit 1
          fi

          echo "Continuing (no fail-set findings or policy disabled)."


      - name: Upload SARIF to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ env.SARIF_SRC }}
          category: trivy

      # ---------- Azure uploads (pretty names under one “folder” path) ----------
      - name: Ensure Azure containers
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_to_azure }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            az storage container create --name "${{ inputs.storage_container_sboms }}"  --account-name "${AZURE_STORAGE_ACCOUNT}" --auth-mode login >/dev/null
            az storage container create --name "${{ inputs.storage_container_scans }}" --account-name "${AZURE_STORAGE_ACCOUNT}" --auth-mode login >/dev/null
            az storage container create --name "${{ inputs.storage_container_runs }}"  --account-name "${AZURE_STORAGE_ACCOUNT}" --auth-mode login >/dev/null

      - name: Upload SBOM to Azure Storage
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_to_azure }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            cp -f "${SBOM_SRC}" "${SBOM_FILE}"
            az storage blob upload \
              --account-name "${AZURE_STORAGE_ACCOUNT}" \
              --container-name "${{ inputs.storage_container_sboms }}" \
              --file "${SBOM_FILE}" \
              --name "${BLOB_PREFIX}/${SBOM_FILE}" \
              --overwrite \
              --auth-mode login
            SBOM_URL=$(az storage blob url --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ inputs.storage_container_sboms }}" --name "${BLOB_PREFIX}/${SBOM_FILE}" -o tsv)
            echo "SBOM_URL=$SBOM_URL" >> $GITHUB_ENV

      - name: Upload Trivy report to Azure Storage
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_to_azure }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            cp -f "${TRIVY_SRC}" "${TRIVY_FILE}"
            az storage blob upload \
              --account-name "${AZURE_STORAGE_ACCOUNT}" \
              --container-name "${{ inputs.storage_container_scans }}" \
              --file "${TRIVY_FILE}" \
              --name "${BLOB_PREFIX}/${TRIVY_FILE}" \
              --overwrite \
              --auth-mode login
            TRIVY_URL=$(az storage blob url --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ inputs.storage_container_scans }}" --name "${BLOB_PREFIX}/${TRIVY_FILE}" -o tsv)
            echo "TRIVY_URL=$TRIVY_URL" >> $GITHUB_ENV

      # ---------- Upload each artifact as a single file ----------
      - name: Upload SBOM artifact
        if: ${{ always() && (github.event_name != 'workflow_dispatch' || inputs.upload_artifacts) && hashFiles('sbom.cyclonedx.json') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: sbom.cyclonedx.json

      - name: Upload Trivy JSON artifact
        if: ${{ always() && (github.event_name != 'workflow_dispatch' || inputs.upload_artifacts) && hashFiles('trivy-report.json') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: trivy-json-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: trivy-report.json

      - name: Upload Trivy SARIF artifact
        if: ${{ always() && (github.event_name != 'workflow_dispatch' || inputs.upload_artifacts) && hashFiles('trivy-results.sarif') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: trivy-sarif-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: trivy-results.sarif

      # ---------- Deploy to Azure Container Instances (CLI) ----------
      - name: Deploy to Azure Container Instance
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          AZURE_CONTAINER_NAME: ${{ env.AZURE_CONTAINER_NAME }}
          ACR_LOGIN_SERVER:     ${{ env.ACR_LOGIN_SERVER }}
          ACR_USERNAME:         ${{ env.ACR_USERNAME }}
          ACR_PASSWORD:         ${{ env.ACR_PASSWORD }}
          IMAGE_NAME:           ${{ env.IMAGE_NAME }}
          IMAGE_TAG:            ${{ env.IMAGE_TAG }}
        run: |
          set -euo pipefail
          if az container show --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_CONTAINER_NAME" --only-show-errors --output none 2>/dev/null; then
            az container delete --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_CONTAINER_NAME" --yes
            for i in {1..30}; do
              if ! az container show --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_CONTAINER_NAME" &>/dev/null; then break; fi
              sleep 5
            done
          fi
          az container create \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$AZURE_CONTAINER_NAME" \
            --image "$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG" \
            --registry-login-server "$ACR_LOGIN_SERVER" \
            --registry-username     "$ACR_USERNAME" \
            --registry-password     "$ACR_PASSWORD" \
            --cpu 1 --memory 1 \
            --os-type Linux \
            --ports 80 \
            --ip-address Public
          PUBLIC_IP=$(az container show --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_CONTAINER_NAME" --query "ipAddress.ip" -o tsv)
          echo "http://$PUBLIC_IP" > "${DEPLOY_SRC}"
          echo "ACI_URL=http://${PUBLIC_IP}" >> $GITHUB_ENV
          test -s "${DEPLOY_SRC}"

      - name: Upload deploy endpoint artifact
        if: ${{ always() && (github.event_name != 'workflow_dispatch' || inputs.upload_artifacts) && hashFiles('aci-endpoint.txt') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: aci-deploy-info-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: aci-endpoint.txt

      # ---------- Build & upload RUN JSON ----------
      - name: Ensure jq present (for RUN JSON)
        run: jq --version || (sudo apt-get update -y && sudo apt-get install -y jq)

      - name: Build run JSON payload (pretty name for Azure; fixed for artifact)
        run: |
          set -euo pipefail
          SBOM_LINK="${SBOM_URL:-}"
          TRIVY_LINK="${TRIVY_URL:-}"
          jq -n \
            --arg id              "${RUN_ID}" \
            --arg projectName     "${PROJECT_NAME}" \
            --arg runNumber       "${RUN_NUMBER}" \
            --arg repo            "${GITHUB_REPOSITORY}" \
            --arg workflow        "${GITHUB_WORKFLOW}" \
            --arg ref             "${GITHUB_REF}" \
            --arg sha             "${GITHUB_SHA}" \
            --arg timestamp       "${RUN_TIMESTAMP}" \
            --arg actionsRunUrl   "${ACTIONS_RUN_URL}" \
            --arg acr             "${ACR_LOGIN_SERVER}" \
            --arg imageName       "${IMAGE_NAME}" \
            --arg imageTag        "${IMAGE_TAG}" \
            --arg imageDigest     "${IMAGE_DIGEST}" \
            --arg sbomFile        "${SBOM_FILE}" \
            --arg trivyFile       "${TRIVY_FILE}" \
            --arg sarifFile       "${SARIF_FILE}" \
            --arg sbomUrl         "${SBOM_LINK}" \
            --arg trivyUrl        "${TRIVY_LINK}" \
            --arg aciName         "${AZURE_CONTAINER_NAME}" \
            --arg aciRg           "${AZURE_RESOURCE_GROUP}" \
            --arg aciUrl          "${ACI_URL:-}" \
            --arg cosignStatus    "${COSIGN_VERIFY_STATUS:-unknown}" \
            --arg sevLevels       "${TRIVY_SEVERITY}" \
            --argjson ignoreUnfix ${TRIVY_IGNORE_UNFIXED} \
            --argjson findings    ${TRIVY_FINDINGS:-0} \
            '{
              id: $id, projectName: $projectName, createdAt: $timestamp,
              repository: $repo, workflow: $workflow, ref: $ref, commitSha: $sha,
              run: { id: $id, number: $runNumber, url: $actionsRunUrl },
              image: { registry: $acr, name: $imageName, tag: $imageTag, digest: $imageDigest },
              artifacts: {
                azure: ( ($sbomUrl|length)>0 or ($trivyUrl|length)>0 ) as $hasAzure
                  | if $hasAzure then { sbom: $sbomUrl, trivy: $trivyUrl } else null end,
                files: { sbom: $sbomFile, trivy: $trivyFile, sarif: $sarifFile }
              },
              assessment: {
                cosign: { verifyStatus: $cosignStatus },
                trivy: { severity: $sevLevels, ignoreUnfixed: $ignoreUnfix, findings: $findings }
              },
              deployment: { aci: { name: $aciName, resourceGroup: $aciRg, url: $aciUrl } }
            }' > "${RUNJSON_SRC}"
          test -s "${RUNJSON_SRC}"
          ls -l "${RUNJSON_SRC}"

      - name: Upload RUN JSON to Azure Storage (pretty name)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.upload_to_azure }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            cp -f "${RUNJSON_SRC}" "${RUN_JSON_FILE}"
            az storage blob upload \
              --account-name "${AZURE_STORAGE_ACCOUNT}" \
              --container-name "${{ inputs.storage_container_runs }}" \
              --file "${RUN_JSON_FILE}" \
              --name "${BLOB_PREFIX}/${RUN_JSON_FILE}" \
              --overwrite \
              --auth-mode login

      - name: Upload RUN JSON artifact
        if: ${{ always() && (github.event_name != 'workflow_dispatch' || inputs.upload_artifacts) && hashFiles('run.json') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: swft-run-json-${{ env.PROJECT_NAME }}-${{ env.RUN_ID }}
          path: run.json
